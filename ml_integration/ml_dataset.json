[
  {
    "code": "def twoSum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "algorithm_type": "hash_table",
    "patterns": [
      "single_loop",
      "hash_lookup"
    ],
    "confidence": 0.95,
    "source": "leetcode",
    "features": {
      "code_length": 216,
      "line_count": 7,
      "function_count": 1,
      "loop_count": 1,
      "recursion_count": 0,
      "data_structure_count": 2,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 1,
        "logarithmic": 0,
        "exponential": 4
      },
      "ast_depth": 8,
      "ast_node_count": 60
    }
  },
  {
    "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "language": "python",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "algorithm_type": "binary_search",
    "patterns": [
      "while_loop",
      "midpoint_calculation"
    ],
    "confidence": 0.95,
    "source": "leetcode",
    "features": {
      "code_length": 290,
      "line_count": 10,
      "function_count": 1,
      "loop_count": 1,
      "recursion_count": 0,
      "data_structure_count": 0,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 0,
        "logarithmic": 1,
        "exponential": 6
      },
      "ast_depth": 8,
      "ast_node_count": 87
    }
  },
  {
    "code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr",
    "language": "python",
    "time_complexity": "O(n\u00b2)",
    "space_complexity": "O(1)",
    "algorithm_type": "sorting",
    "patterns": [
      "nested_loops",
      "swapping"
    ],
    "confidence": 0.95,
    "source": "leetcode",
    "features": {
      "code_length": 206,
      "line_count": 6,
      "function_count": 1,
      "loop_count": 2,
      "recursion_count": 0,
      "data_structure_count": 0,
      "complexity_keywords": {
        "linear": 2,
        "quadratic": 4,
        "logarithmic": 0,
        "exponential": 4
      },
      "ast_depth": 10,
      "ast_node_count": 92
    }
  },
  {
    "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)",
    "language": "python",
    "time_complexity": "O(2\u207f)",
    "space_complexity": "O(n)",
    "algorithm_type": "recursion",
    "patterns": [
      "recursive_call",
      "base_case"
    ],
    "confidence": 0.95,
    "source": "leetcode",
    "features": {
      "code_length": 92,
      "line_count": 3,
      "function_count": 1,
      "loop_count": 0,
      "recursion_count": 0,
      "data_structure_count": 0,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 0,
        "logarithmic": 0,
        "exponential": 6
      },
      "ast_depth": 7,
      "ast_node_count": 32
    }
  },
  {
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "language": "python",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "algorithm_type": "divide_conquer",
    "patterns": [
      "recursive_call",
      "merging",
      "divide"
    ],
    "confidence": 0.95,
    "source": "leetcode",
    "features": {
      "code_length": 531,
      "line_count": 24,
      "function_count": 2,
      "loop_count": 1,
      "recursion_count": 0,
      "data_structure_count": 1,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 0,
        "logarithmic": 1,
        "exponential": 39
      },
      "ast_depth": 8,
      "ast_node_count": 175
    }
  },
  {
    "code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)",
    "language": "python",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(log n)",
    "algorithm_type": "sorting",
    "patterns": [
      "recursive_call",
      "pivot_selection",
      "partitioning"
    ],
    "confidence": 0.95,
    "source": "github",
    "features": {
      "code_length": 286,
      "line_count": 9,
      "function_count": 1,
      "loop_count": 3,
      "recursion_count": 0,
      "data_structure_count": 0,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 9,
        "logarithmic": 1,
        "exponential": 10
      },
      "ast_depth": 7,
      "ast_node_count": 99
    }
  },
  {
    "code": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    \n    visited.add(start)\n    print(start)\n    \n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)",
    "language": "python",
    "time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "algorithm_type": "graph_traversal",
    "patterns": [
      "recursive_call",
      "visited_set",
      "graph_iteration"
    ],
    "confidence": 0.95,
    "source": "github",
    "features": {
      "code_length": 246,
      "line_count": 9,
      "function_count": 1,
      "loop_count": 1,
      "recursion_count": 0,
      "data_structure_count": 1,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 1,
        "logarithmic": 0,
        "exponential": 0
      },
      "ast_depth": 7,
      "ast_node_count": 59
    }
  },
  {
    "code": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n            \n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances",
    "language": "python",
    "time_complexity": "O((V + E) log V)",
    "space_complexity": "O(V)",
    "algorithm_type": "shortest_path",
    "patterns": [
      "priority_queue",
      "graph_iteration",
      "heap_operations"
    ],
    "confidence": 0.95,
    "source": "textbook",
    "features": {
      "code_length": 624,
      "line_count": 20,
      "function_count": 1,
      "loop_count": 3,
      "recursion_count": 0,
      "data_structure_count": 5,
      "complexity_keywords": {
        "linear": 0,
        "quadratic": 4,
        "logarithmic": 0,
        "exponential": 7
      },
      "ast_depth": 9,
      "ast_node_count": 131
    }
  },
  {
    "code": "def fibonacci_dp(n):\n    if n <= 1:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "algorithm_type": "dynamic_programming",
    "patterns": [
      "single_loop",
      "memoization",
      "array_access"
    ],
    "confidence": 0.95,
    "source": "textbook",
    "features": {
      "code_length": 185,
      "line_count": 10,
      "function_count": 1,
      "loop_count": 1,
      "recursion_count": 0,
      "data_structure_count": 0,
      "complexity_keywords": {
        "linear": 1,
        "quadratic": 1,
        "logarithmic": 0,
        "exponential": 6
      },
      "ast_depth": 8,
      "ast_node_count": 79
    }
  }
]