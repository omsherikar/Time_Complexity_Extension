[
  {
    "code": "\ndef constant_time_operation():\n    return 42\n",
    "language": "python",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)",
    "algorithm_type": "constant",
    "patterns": [
      "constant_operation"
    ],
    "confidence": 0.95,
    "source": "basic_algorithms",
    "difficulty": "easy",
    "description": "Simple constant time operation"
  },
  {
    "code": "\ndef array_access(arr, index):\n    return arr[index]\n",
    "language": "python",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)",
    "algorithm_type": "array_access",
    "patterns": [
      "array_access"
    ],
    "confidence": 0.95,
    "source": "basic_algorithms",
    "difficulty": "easy",
    "description": "Array element access"
  },
  {
    "code": "\ndef linear_search(arr, target):\n    for i, num in enumerate(arr):\n        if num == target:\n            return i\n    return -1\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "algorithm_type": "linear_search",
    "patterns": [
      "single_loop",
      "linear_search"
    ],
    "confidence": 0.95,
    "source": "basic_algorithms",
    "difficulty": "easy",
    "description": "Linear search through array"
  },
  {
    "code": "\ndef sum_array(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "algorithm_type": "array_sum",
    "patterns": [
      "single_loop",
      "accumulation"
    ],
    "confidence": 0.95,
    "source": "basic_algorithms",
    "difficulty": "easy",
    "description": "Sum all elements in array"
  },
  {
    "code": "\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n",
    "language": "python",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "algorithm_type": "binary_search",
    "patterns": [
      "while_loop",
      "midpoint_calculation",
      "binary_search"
    ],
    "confidence": 0.95,
    "source": "basic_algorithms",
    "difficulty": "medium",
    "description": "Binary search in sorted array"
  },
  {
    "code": "\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n",
    "language": "python",
    "time_complexity": "O(n\u00b2)",
    "space_complexity": "O(1)",
    "algorithm_type": "sorting",
    "patterns": [
      "nested_loops",
      "swapping"
    ],
    "confidence": 0.95,
    "source": "sorting_algorithms",
    "difficulty": "easy",
    "description": "Bubble sort implementation"
  },
  {
    "code": "\ndef quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)\n",
    "language": "python",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(log n)",
    "algorithm_type": "sorting",
    "patterns": [
      "recursion",
      "divide_conquer",
      "pivot_selection"
    ],
    "confidence": 0.95,
    "source": "sorting_algorithms",
    "difficulty": "medium",
    "description": "Quick sort with divide and conquer"
  },
  {
    "code": "\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n",
    "language": "python",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "algorithm_type": "sorting",
    "patterns": [
      "recursion",
      "divide_conquer",
      "merging"
    ],
    "confidence": 0.95,
    "source": "sorting_algorithms",
    "difficulty": "medium",
    "description": "Merge sort with divide and conquer"
  },
  {
    "code": "\ndef dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    \n    visited.add(start)\n    print(start)\n    \n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n",
    "language": "python",
    "time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "algorithm_type": "graph_traversal",
    "patterns": [
      "recursion",
      "graph_traversal",
      "visited_set"
    ],
    "confidence": 0.95,
    "source": "search_algorithms",
    "difficulty": "medium",
    "description": "Depth first search on graph"
  },
  {
    "code": "\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        vertex = queue.popleft()\n        print(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n",
    "language": "python",
    "time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "algorithm_type": "graph_traversal",
    "patterns": [
      "queue",
      "graph_traversal",
      "visited_set"
    ],
    "confidence": 0.95,
    "source": "search_algorithms",
    "difficulty": "medium",
    "description": "Breadth first search on graph"
  },
  {
    "code": "\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n            \n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n",
    "language": "python",
    "time_complexity": "O((V + E) log V)",
    "space_complexity": "O(V)",
    "algorithm_type": "shortest_path",
    "patterns": [
      "priority_queue",
      "graph_traversal",
      "distance_update"
    ],
    "confidence": 0.95,
    "source": "graph_algorithms",
    "difficulty": "hard",
    "description": "Dijkstra's shortest path algorithm"
  },
  {
    "code": "\ndef fibonacci_dp(n):\n    if n <= 1:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "algorithm_type": "dynamic_programming",
    "patterns": [
      "memoization",
      "bottom_up",
      "array_dp"
    ],
    "confidence": 0.95,
    "source": "dynamic_programming",
    "difficulty": "medium",
    "description": "Fibonacci with dynamic programming"
  },
  {
    "code": "\ndef lcs(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]\n",
    "language": "python",
    "time_complexity": "O(mn)",
    "space_complexity": "O(mn)",
    "algorithm_type": "dynamic_programming",
    "patterns": [
      "2d_dp",
      "string_matching",
      "maximization"
    ],
    "confidence": 0.95,
    "source": "dynamic_programming",
    "difficulty": "hard",
    "description": "Longest common subsequence"
  },
  {
    "code": "\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "algorithm_type": "recursion",
    "patterns": [
      "recursion",
      "base_case",
      "linear_recursion"
    ],
    "confidence": 0.95,
    "source": "recursive_algorithms",
    "difficulty": "easy",
    "description": "Recursive factorial calculation"
  },
  {
    "code": "\ndef tower_of_hanoi(n, source, auxiliary, target):\n    if n == 1:\n        print(f\"Move disk 1 from {source} to {target}\")\n        return\n    \n    tower_of_hanoi(n-1, source, target, auxiliary)\n    print(f\"Move disk {n} from {source} to {target}\")\n    tower_of_hanoi(n-1, auxiliary, source, target)\n",
    "language": "python",
    "time_complexity": "O(2\u207f)",
    "space_complexity": "O(n)",
    "algorithm_type": "recursion",
    "patterns": [
      "recursion",
      "divide_conquer",
      "exponential"
    ],
    "confidence": 0.95,
    "source": "recursive_algorithms",
    "difficulty": "medium",
    "description": "Tower of Hanoi recursive solution"
  },
  {
    "code": "\ndef reverse_string(s):\n    return s[::-1]\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "algorithm_type": "string_manipulation",
    "patterns": [
      "string_slicing"
    ],
    "confidence": 0.95,
    "source": "string_algorithms",
    "difficulty": "easy",
    "description": "String reversal using slicing"
  },
  {
    "code": "\ndef inorder_traversal(root):\n    if root:\n        inorder_traversal(root.left)\n        print(root.val)\n        inorder_traversal(root.right)\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)",
    "algorithm_type": "tree_traversal",
    "patterns": [
      "recursion",
      "tree_traversal",
      "inorder"
    ],
    "confidence": 0.95,
    "source": "tree_algorithms",
    "difficulty": "medium",
    "description": "Inorder tree traversal"
  },
  {
    "code": "\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "algorithm_type": "hash_table",
    "patterns": [
      "hash_table",
      "complement_search"
    ],
    "confidence": 0.95,
    "source": "array_algorithms",
    "difficulty": "easy",
    "description": "Two sum using hash table"
  },
  {
    "code": "\ndef max_sum_subarray(arr, k):\n    max_sum = 0\n    window_sum = 0\n    \n    for i in range(len(arr)):\n        window_sum += arr[i]\n        if i >= k - 1:\n            max_sum = max(max_sum, window_sum)\n            window_sum -= arr[i - k + 1]\n    \n    return max_sum\n",
    "language": "python",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "algorithm_type": "sliding_window",
    "patterns": [
      "sliding_window",
      "window_sum"
    ],
    "confidence": 0.95,
    "source": "advanced_patterns",
    "difficulty": "medium",
    "description": "Maximum sum subarray with sliding window"
  }
]